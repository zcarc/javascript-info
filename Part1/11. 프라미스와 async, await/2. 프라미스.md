# 프라미스

## loadScript 함수를 프라미스로 다시 작성

```js
function loadScript(src) {
  return new Promise(function (resolve, reject) {
    let script = document.createElement("script");
    script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () =>
      reject(new Error(`${src}를 불러오는 도중에 에러가 발생함`));

    document.head.append(script);
  });
}

let promise = loadScript(
  "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"
);

promise.then(
  (script) => alert(`${script.src}을 불러왔습니다!`),
  (error) => alert(`Error: ${error.message}`)
);

promise.then((script) => alert("또다른 핸들러..."));
```

## 과제

### 두 번 resolve 하기?

아래 코드의 실행 결과를 예측해보세요.

```js
let promise = new Promise(function (resolve, reject) {
  resolve(1);

  setTimeout(() => resolve(2), 1000);
});

promise.then(alert);
```

<details>
<summary>해답</summary>

```
1이 출력됩니다.

첫 번째 reject/resolve 호출만 고려대상이기 때문에 두 번째 resolve는 무시되기 때문입니다.
```

</details>

### 프라미스로 지연 만들기

내장 함수 setTimeout은 콜백을 사용합니다. 프라미스를 기반으로 하는 동일 기능 함수를 만들어보세요.

함수 delay(ms)는 프라미스를 반환해야 합니다. 반환되는 프라미스는 아래와 같이 .then을 붙일 수 있도록 ms 이후에 이행되어야 합니다.

```js
function delay(ms) {
  // 여기에 코드 작성
}

delay(3000).then(() => alert("3초후 실행"));
```

<details>
<summary>해답</summary>

```js
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

delay(3000).then(() => alert("3초후 실행"));
```

답안에서 resolve가 인수 없이 호출되었다는 것에 주목해주시기 바랍니다. 함수 delay는 지연 확인 용이기 때문에 반환 값이 필요 없습니다.

</details>
